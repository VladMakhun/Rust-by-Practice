1. 
fn main() {
    let i1: i32 = false.into();
    let i2: i32 = i32::from(false);
    assert_eq!(i1, i2);
    assert_eq!(i1, 0);

    let i3: i32 = 'a' as u32 as i32;

    let i4: i32 = 'a' as i32;

    assert_eq!(i3, 97); 
    assert_eq!(i4, 97); 

    let s: String = String::from('a');

    let s2: String = 'a'.to_string();

    assert_eq!(s, s2);
    
    println!("Success!");
}

2. 
#[derive(Debug)]
struct Number {
    value: i32,
}

impl From<i32> for Number {
    // Implementing the `from` method
    fn from(value: i32) -> Self {
        Number { value }
    }
}

// FILL in the blanks
fn main() {
    let num = Number::from(30); // Creating a Number instance using From
    assert_eq!(num.value, 30);

    let num: Number = 30.into(); // Using the `into` method to convert
    assert_eq!(num.value, 30);

    println!("Success!");
}

3. ðŸŒŸðŸŒŸðŸŒŸ When performing error handling it is often useful to implement From trait for our own error type. Then we can use ? to automatically convert the underlying error type to our own error type.

use std::fs;
use std::io;
use std::num;

enum CliError {
    IoError(io::Error),
    ParseError(num::ParseIntError),
}

// Implement From for io::Error
impl From<io::Error> for CliError {
    fn from(error: io::Error) -> CliError {
        CliError::IoError(error)
    }
}

// Implement From for num::ParseIntError
impl From<num::ParseIntError> for CliError {
    fn from(error: num::ParseIntError) -> CliError {
        CliError::ParseError(error)
    }
}

fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {
    // ? automatically converts io::Error to CliError
    let contents = fs::read_to_string(&file_name)?;
    // num::ParseIntError -> CliError
    let num: i32 = contents.trim().parse()?;
    Ok(num)
}

fn main() {
    // Example usage
    match open_and_parse_file("numbers.txt") {
        Ok(value) => println!("Parsed number: {}", value),
        Err(e) => match e {
            CliError::IoError(err) => eprintln!("IO Error: {}", err),
            CliError::ParseError(err) => eprintln!("Parse Error: {}", err),
        },
    }

    println!("Success!");
}


4 .
// TryFrom and TryInto are included in `std::prelude`, so there is no need to introduce it into the current scope
// use std::convert::TryInto;

fn main() {
    let n: i16 = 256;

    // TryInto has a method try_into
    let n: u8 = match n.try_into() {
        Ok(n) => n,
        Err(e) => {
            println!("there is an error when converting: {:?}, but we catch it", e.to_string());
            0
        }
    };

    assert_eq!(n, 0); // Since 256 cannot be converted to u8, the assert should check against 0

    println!("Success!");
}

5. 
#[derive(Debug, PartialEq)]
struct EvenNum(i32);

impl TryFrom<i32> for EvenNum {
    type Error = ();

    // Implement `try_from`
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNum(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    assert_eq!(EvenNum::try_from(8), Ok(EvenNum(8)));
    assert_eq!(EvenNum::try_from(5), Err(()));

    // Fill in the blanks
    let result: Result<EvenNum, ()> = 8i32.try_into();
    assert_eq!(result, Ok(EvenNum(8))); // Expecting Ok(EvenNum(8))
    let result: Result<EvenNum, ()> = 5i32.try_into();
    assert_eq!(result, Err(())); // Expecting Err(())

    println!("Success!");
}


