1. 
fn main() {
    let arr: [u8; 3] = [1, 2, 3];
    
    let v = Vec::from(arr);
    is_vec(&v);

    let v = vec![1, 2, 3];
    is_vec(&v);

    // vec!(..) and vec![..] are same macros, so
    let v = vec!(1, 2, 3);
    is_vec(&v);
    
    // In code below, v1 is Vec<[u8; 3]>, not Vec<u8>
    // USE Vec::new and `for` to rewrite the below code
    let mut v1 = Vec::new();
    for &x in arr.iter() {
        v1.push(x);
    }
    is_vec(&v1);
 
    assert_eq!(v, v1);

    println!("Success!");
}

fn is_vec(v: &Vec<u8>) {}

2. ðŸŒŸðŸŒŸ A Vec can be extended with extend method


// FILL in the blank
fn main() {
    let mut v1 = Vec::from([1, 2, 4]);
    v1.pop();
    v1.push(3);
    
    let mut v2 = Vec::new();
    v2.push(0);

    assert_eq!(v1, v2);

    println!("Success!");
}

3. 
fn main() {
  
    let arr = [1, 2, 3];
    let v1 = Vec::from(arr);  
    let v2: Vec<i32> = arr.to_vec();
 
    assert_eq!(v1, v2);
 
    let s = "hello".to_string();
    let v1: Vec<u8> = s.as_bytes().to_vec(); 

    let s = "hello".to_string();
    let v2 = s.into_bytes();  
    assert_eq!(v1, v2);

    // impl<'_> From<&'_ str> for Vec
    let s = "hello";
    let v3 = Vec::from(s);  
    assert_eq!(v2, v3);

    let v4: Vec<i32> = [0; 10].into_iter().collect();  
    assert_eq!(v4, vec![0; 10]);

    println!("Success!");
}

4. FIX the error and IMPLEMENT the code

fn main() {
    let mut v = Vec::from([1, 2, 3]);

    for i in 0..v.len() {
        println!("{:?}", v[i]);
    }

    for i in 0..5 {
        if i < v.len() {
            v[i] += 1;  
        } else {
            v.push(i + 2);  
        }
    }

    assert_eq!(v, vec![2, 3, 4, 5, 6]);

    println!("Success!");
}

5. 
fn main() {
    let mut v = vec![1, 2, 3];

    let slice1 = &v[..];

    let slice2 = &v[0..v.len()];
    
    assert_eq!(slice1, slice2);
    
 
    let vec_ref: &mut Vec<i32> = &mut v;
    vec_ref.push(4);  


    let slice3 = &v[0..4];  

    assert_eq!(slice3, &[1, 2, 3, 4]);

    println!("Success!");
}

6. fn main() {
    let mut vec = Vec::with_capacity(10);

    assert_eq!(vec.len(), 0); 
    assert_eq!(vec.capacity(), 10); 

    for i in 0..10 {
        vec.push(i);
    }
    assert_eq!(vec.len(), 10); 
    assert_eq!(vec.capacity(), 10); 

    vec.push(11);
    assert_eq!(vec.len(), 11); 
    assert!(vec.capacity() >= 11); 


    let mut vec = Vec::with_capacity(100); 
    for i in 0..100 {
        vec.push(i); 
    }

    assert_eq!(vec.len(), 100); 
    assert_eq!(vec.capacity(), 100); 

    println!("Success!");
}

7. #[derive(Debug, PartialEq)] // Derive PartialEq for comparison
enum IpAddr {
    V4(String),
    V6(String),
}

fn main() {
    let v: Vec<IpAddr> = vec![
        IpAddr::V4("127.0.0.1".to_string()),
        IpAddr::V6("::1".to_string()),
    ];
    
    assert_eq!(v[0], IpAddr::V4("127.0.0.1".to_string()));
    assert_eq!(v[1], IpAddr::V6("::1".to_string()));

    println!("Success!");
}

8. 
trait IpAddr {
    fn display(&self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&self) {
        println!("ipv4: {:?}", self.0);
    }
}

struct V6(String);
impl IpAddr for V6 {
    fn display(&self) {
        println!("ipv6: {:?}", self.0);
    }
}

fn main() {
    let v: Vec<Box<dyn IpAddr>> = vec![
        Box::new(V4("127.0.0.1".to_string())),
        Box::new(V6("::1".to_string())),
    ];

    for ip in v {
        ip.display();
    }
}




